<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Squardle — 3×3</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  body{max-width:820px;margin:18px auto;padding:0 16px;color:#111;}
  h1{font-size:1.05rem;margin:0 0 12px;}
  .grid{display:grid;grid-template-columns:repeat(3,80px);gap:8px;margin-bottom:12px;user-select:none;}
  .cell{width:80px;height:80px;display:flex;align-items:center;justify-content:center;
        border-radius:10px;background:#fff;border:2px solid #111;font-weight:800;font-size:32px;cursor:pointer;}
  .cell.selected{outline:5px solid #111; box-shadow:0 6px 18px rgba(0,0,0,.08);}
  /* subtle solved marker — does NOT block selection or turn the tile black */
  .cell.solved{
    background: transparent;
    color: inherit;
    box-shadow: inset 0 -6px 0 rgba(0,0,0,0.06);
  }
  .cell.gray{opacity:.28;filter:grayscale(100%);cursor:not-allowed;border-color:#aaa;}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap;}
  input[type="text"]{padding:8px 10px;font-size:16px;border-radius:6px;border:1px solid #ccc;width:260px;}
  button{padding:8px 10px;border-radius:6px;border:0;background:#111;color:#fff;cursor:pointer;}
  button.secondary{background:#6b7280;}
  .msg{margin-top:8px;color:#b91c1c;font-weight:600;min-height:20px;}
  .small{font-size:13px;color:#374151;margin-top:10px;}
  .solved-list{margin-top:12px;padding-left:18px;}
  .counters{margin-top:8px;font-size:14px;}
  .row{display:flex;gap:8px;align-items:center;}
  @media (max-width:420px){
    .grid{grid-template-columns:repeat(3,64px);gap:6px}
    .cell{width:64px;height:64px;font-size:26px}
    input[type="text"]{width:160px}
  }
</style>
</head>
<body>

<h1>Hi lovelies</h1>

<div id="grid" class="grid" aria-label="3x3 grid"></div>

<div class="controls">
  <input id="guessInput" placeholder="Click letters or type a guess" autocomplete="off" />
  <button id="submitBtn">Submit</button>
  <button id="clearBtn" class="secondary">Clear</button>
  <button id="resetBtn" class="secondary">Reset Game</button>
</div>

<div class="msg" id="msg"></div>

<div class="counters" id="counters"></div>

<div class="small"><strong>Solved:</strong></div>
<ul id="solvedList" class="solved-list"></ul>

<script>
/* ===================
   CONFIGURATION
   =================== */
/* 3x3 letters (row-major) */
const GRID = [
  ['Y','T','R'],
  ['A','I','H'],
  ['B','D','C']
];

/* allowed words (your list) */
const ALLOWED_WORDS = [
  "bait","bath","chia","chit","city","dirt","rich",
  "birth","dirty","triad",
  "birthday"
].map(s=>s.toLowerCase());

/* adjacency neighbors (0..8 indexing) -- 8-directional */
const NEIGHBORS = {
  0:[1,3,4], 1:[0,2,3,4,5], 2:[1,4,5],
  3:[0,1,4,6,7], 4:[0,1,2,3,5,6,7,8], 5:[1,2,4,7,8],
  6:[3,4,7], 7:[3,4,5,6,8], 8:[4,5,7]
};

/* ===================
   STATE
   =================== */
const rows = GRID.length;
const cols = GRID[0].length;
const cells = {};            // "r-c" -> {el, r, c, ch, idx}
let currentPath = [];        // array of indices (0..8)
let mouseDown = false;
let solvedWords = new Set();
let remaining = new Set(ALLOWED_WORDS);

/* Precompute: map char -> set(words that contain char) for graying logic */
const charToAllWords = {};
ALLOWED_WORDS.forEach(w=>{
  new Set(w.split('')).forEach(ch=>{
    if(!charToAllWords[ch]) charToAllWords[ch] = new Set();
    charToAllWords[ch].add(w);
  });
});

/* Precompute words by length for counters */
const wordsByLen = {};
ALLOWED_WORDS.forEach(w=>{
  const L = w.length;
  if(!wordsByLen[L]) wordsByLen[L] = [];
  wordsByLen[L].push(w);
});

/* ===================
   UI ELEMENTS
   =================== */
const gridEl = document.getElementById('grid');
const guessInput = document.getElementById('guessInput');
const submitBtn = document.getElementById('submitBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');
const msgEl = document.getElementById('msg');
const solvedListEl = document.getElementById('solvedList');
const countersEl = document.getElementById('counters');

/* ===================
   BUILD GRID UI
   =================== */
let idx = 0;
for(let r=0;r<rows;r++){
  for(let c=0;c<cols;c++){
    const ch = GRID[r][c];
    const el = document.createElement('div');
    el.className = 'cell';
    el.textContent = ch;
    el.dataset.r = r;
    el.dataset.c = c;
    el.dataset.ch = ch.toLowerCase();
    el.dataset.idx = idx;
    // mouse events for click + drag
    el.addEventListener('mousedown', (e)=>{ e.preventDefault(); onMouseDownCell(+el.dataset.idx); });
    el.addEventListener('mouseover', ()=> onMouseOverCell(+el.dataset.idx));
    el.addEventListener('click', ()=> onClickCell(+el.dataset.idx));
    gridEl.appendChild(el);
    cells[idx] = {el, r, c, ch: ch.toLowerCase(), idx};
    idx++;
  }
}

/* ===================
   INPUT / MOUSE HANDLERS
   =================== */
document.addEventListener('mouseup', ()=> { mouseDown = false; }); // end drag anywhere on doc

function onMouseDownCell(i){
  mouseDown = true;
  if(isGrayed(i)) return;
  // If clicking last selected -> deselect (backspace)
  if(currentPath.length && currentPath[currentPath.length-1] === i){
    popLast();
    return;
  }
  // If already in path (but not last) -> ignore
  if(currentPath.includes(i)) return;
  // If path non-empty, must be neighbor
  if(currentPath.length && !NEIGHBORS[currentPath[currentPath.length-1]].includes(i)) return;
  pushIndex(i);
}

function onMouseOverCell(i){
  if(!mouseDown) return;
  if(isGrayed(i)) return;
  if(currentPath.length && currentPath[currentPath.length-1] === i){
    // nothing
    return;
  }
  if(currentPath.includes(i)) return; // cannot reuse
  if(currentPath.length && !NEIGHBORS[currentPath[currentPath.length-1]].includes(i)) return;
  pushIndex(i);
}

function onClickCell(i){
  // Single click behavior: if not selected, select (if adjacent or start). If it's last selected, deselect.
  if(isGrayed(i)) return;
  if(currentPath.length && currentPath[currentPath.length-1] === i){
    popLast();
    return;
  }
  if(currentPath.includes(i)) return;
  if(currentPath.length && !NEIGHBORS[currentPath[currentPath.length-1]].includes(i)) return;
  pushIndex(i);
}

/* selection helpers */
function pushIndex(i){
  currentPath.push(i);
  cells[i].el.classList.add('selected');
  updateGuessInputFromPath();
}

function popLast(){
  const i = currentPath.pop();
  if(typeof i !== 'undefined') cells[i].el.classList.remove('selected');
  updateGuessInputFromPath();
}

function clearSelection(){
  currentPath.forEach(i=>cells[i].el.classList.remove('selected'));
  currentPath = [];
  updateGuessInputFromPath();
}

function updateGuessInputFromPath(){
  const s = currentPath.map(i=>cells[i].ch).join('');
  guessInput.value = s;
}

/* ===================
   Path-finding & validation
   =================== */
/* DFS path finder: returns a path (array of indices) if this word exists on board by adjacency without reuse */
function findPathForWord(word){
  word = word.toLowerCase();
  const L = word.length;
  const visited = Array(9).fill(false);

  function dfs(idxPos, at){
    if(cells[at].ch !== word[idxPos]) return null;
    if(idxPos === L-1) return [at];
    visited[at] = true;
    for(const nb of NEIGHBORS[at]){
      if(visited[nb]) continue;
      if(cells[nb].ch !== word[idxPos+1]) continue;
      const sub = dfs(idxPos+1, nb);
      if(sub){
        visited[at] = false;
        return [at, ...sub];
      }
    }
    visited[at] = false;
    return null;
  }

  for(let start=0; start<9; start++){
    if(cells[start].ch === word[0]){
      const p = dfs(0, start);
      if(p) return p;
    }
  }
  return null;
}

/* ===================
   Submit / Evaluate
   =================== */
function setMsg(t){ msgEl.textContent = t; }
function clearMsg(){ msgEl.textContent = ''; }
function isGrayed(i){ return cells[i].el.classList.contains('gray'); }

submitBtn.addEventListener('click', processSubmit);
guessInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') processSubmit(); });

function processSubmit(){
  clearMsg();
  const guess = guessInput.value.trim().toLowerCase();
  if(!guess){ setMsg('Enter a guess or click letters.'); return; }
  if(!ALLOWED_WORDS.includes(guess)){ setMsg('Not an allowed word.'); return; }
  if(solvedWords.has(guess)){ setMsg('Already solved.'); return; }

  // if user built the path manually, we will accept that path only if it exactly matches a valid path for the word.
  // but if typed, lookup any valid path
  let path = null;
  if(currentPath.length && currentPath.map(i=>cells[i].ch).join('') === guess){
    // verify that currentPath is a valid adjacency path (it should be by construction)
    path = [...currentPath];
  } else {
    path = findPathForWord(guess);
  }
  if(!path){ setMsg('No valid path for that word on the board.'); return; }

  // success
  solvedWords.add(guess);
  remaining.delete(guess);
  // record solved usage but DO NOT add the 'solved' class that forces black
  path.forEach(i=>{
    cells[i].el.classList.remove('selected');
    cells[i].el.dataset.used = '1'; // optional bookkeeping only
  });
  updateSolvedUI();
  clearSelection();
  updateGrayOutLetters();
  updateCounters();
}

/* clear button behavior */
clearBtn.addEventListener('click', ()=>{ clearSelection(); clearMsg(); });

/* reset game (clears solved words and restores) */
resetBtn.addEventListener('click', ()=>{
  solvedWords = new Set();
  remaining = new Set(ALLOWED_WORDS);
  // remove solved/gray classes
  Object.values(cells).forEach(cd=>{
    cd.el.classList.remove('solved','gray','selected');
  });
  clearSelection();
  updateSolvedUI();
  updateGrayOutLetters();
  updateCounters();
  clearMsg();
});

/* ===================
   UI updates: solved list, counters, gray-out
   =================== */
function updateSolvedUI(){
  solvedListEl.innerHTML = '';
  Array.from(solvedWords).sort((a,b)=>a.length-b.length).forEach(w=>{
    const li = document.createElement('li');
    li.textContent = w.toUpperCase();
    solvedListEl.appendChild(li);
  });
}

function updateCounters(){
  // counts remaining words by length
  let html = '';
  Object.keys(wordsByLen).sort((a,b)=>a-b).forEach(L=>{
    const total = wordsByLen[L].length;
    const rem = wordsByLen[L].filter(w=>remaining.has(w)).length;
    html += `${L}-letter: ${rem}/${total} &nbsp; `;
  });
  countersEl.innerHTML = html;
}

function updateGrayOutLetters(){
  // compute how many remaining words still reference each char
  const usage = {}; // char -> count
  remaining.forEach(w=>{
      for (const ch of w) {
          usage[ch] = 1;   // presence is enough; we only care if ANY word still uses this letter
      }
  });
  // apply gray class to any cell whose char has usage 0
  Object.values(cells).forEach(cd=>{
    const ch = cd.ch;
    if(!usage[ch]) cd.el.classList.add('gray');
    else cd.el.classList.remove('gray');
  });
}

/* ===================
   Initialization: helper to find any valid path for very long words (not required)
   =================== */
(function init(){
  updateSolvedUI();
  updateCounters();
  updateGrayOutLetters();
  // allow typing to override selection: typing clears selection highlight to avoid mismatch confusion
  guessInput.addEventListener('input', ()=>{ 
    // if user types, deselect UI path (they might type a different path)
    currentPath.forEach(i=>cells[i].el.classList.remove('selected'));
    currentPath = [];
  });
  // accessibility: allow keyboard clear with Escape
  document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') clearSelection(); });
})();
</script>

</body>
</html>
